pub mod catalog;
pub mod expand;
pub mod model;
pub mod query;

/// DDL function implementations — only compiled when building the `DuckDB` extension.
/// The `ddl` module uses `duckdb::vscalar` and `duckdb::vtab`, which are only
/// available when the `extension` feature (and thus `vscalar` + `loadable-extension`)
/// is active.  Under `cargo test` (default `bundled` feature), this module is excluded.
#[cfg(feature = "extension")]
pub mod ddl;

/// Extension entry point — called by `DuckDB` when the extension is loaded.
///
/// Initializes the catalog (`semantic_layer._definitions` schema and table),
/// then registers all four DDL functions on the connection.
///
/// # Safety
///
/// This function is called by `DuckDB` across an FFI boundary. The `con` parameter
/// is provided by `DuckDB` and is guaranteed to be a valid connection handle for
/// the duration of the call. The `#[duckdb_entrypoint_c_api]` macro handles the
/// unsafe C FFI bridging and panic-catching automatically.
#[cfg(feature = "extension")]
mod extension {
    use std::ptr;
    use std::sync::Arc;

    use duckdb::{Connection, Result};
    use libduckdb_sys as ffi;
    use std::error::Error;

    use crate::{
        catalog::init_catalog,
        ddl::{
            define::{DefineSemanticView, DefineState},
            describe::DescribeSemanticViewVTab,
            drop::{DropSemanticView, DropState},
            list::ListSemanticViewsVTab,
        },
        query::table_function::{QueryState, SemanticViewVTab},
    };

    /// Core initialization logic, called with both the high-level Connection and
    /// the raw database handle (extracted by the manual FFI entrypoint below).
    fn init_extension(
        con: &Connection,
        db_handle: ffi::duckdb_database,
    ) -> Result<(), Box<dyn Error>> {
        // Resolve the host database file path by querying PRAGMA database_list.
        let db_path: Arc<str> = {
            let mut stmt = con.prepare("PRAGMA database_list")?;
            let path = stmt
                .query_map([], |row| row.get::<_, String>(2))?
                .filter_map(Result::ok)
                .find(|file| !file.is_empty())
                .unwrap_or_default();
            if path.is_empty() {
                Arc::from(":memory:")
            } else {
                Arc::from(path.as_str())
            }
        };

        // Initialize the catalog.
        let catalog_state = init_catalog(con, &db_path)?;

        // Register scalar DDL mutation functions.
        con.register_scalar_function_with_state::<DefineSemanticView>(
            "define_semantic_view",
            &DefineState {
                catalog: catalog_state.clone(),
                db_path: db_path.clone(),
            },
        )?;
        con.register_scalar_function_with_state::<DropSemanticView>(
            "drop_semantic_view",
            &DropState {
                catalog: catalog_state.clone(),
                db_path: db_path.clone(),
            },
        )?;

        // Register table DDL read functions.
        con.register_table_function_with_extra_info::<ListSemanticViewsVTab, _>(
            "list_semantic_views",
            &catalog_state,
        )?;
        con.register_table_function_with_extra_info::<DescribeSemanticViewVTab, _>(
            "describe_semantic_view",
            &catalog_state,
        )?;

        // Create a NEW connection for the semantic_query table function.
        // The host connection may hold execution locks during query processing.
        // A separate connection avoids lock conflicts when executing the expanded
        // SQL from within the table function.
        let mut query_conn: ffi::duckdb_connection = ptr::null_mut();
        let rc = unsafe { ffi::duckdb_connect(db_handle, &mut query_conn) };
        if rc != ffi::DuckDBSuccess {
            return Err("Failed to create query connection for semantic_query".into());
        }

        // Register the semantic_query table function.
        let query_state = QueryState {
            catalog: catalog_state.clone(),
            conn: query_conn,
        };
        con.register_table_function_with_extra_info::<SemanticViewVTab, _>(
            "semantic_query",
            &query_state,
        )?;

        Ok(())
    }

    // -----------------------------------------------------------------------
    // Manual FFI entrypoint (replaces #[duckdb_entrypoint_c_api()] macro)
    //
    // We write the entrypoint by hand to capture the raw duckdb_database handle
    // BEFORE it is wrapped in a Connection. This avoids unsafe pointer arithmetic
    // to extract private fields from Connection.
    //
    // The implementation mirrors the code generated by `duckdb_entrypoint_c_api`
    // in duckdb-loadable-macros 0.1.14, with the addition of passing `db_handle`
    // to `init_extension`.
    // -----------------------------------------------------------------------

    const MINIMUM_DUCKDB_VERSION: &str = "v1.4.4";

    /// Internal entrypoint with error handling.
    ///
    /// # Safety
    ///
    /// Called by the extern "C" entrypoint below. `info` and `access` must be
    /// valid pointers provided by DuckDB.
    unsafe fn semantic_views_init_c_api_internal(
        info: ffi::duckdb_extension_info,
        access: *const ffi::duckdb_extension_access,
    ) -> std::result::Result<bool, Box<dyn Error>> {
        let have_api_struct =
            ffi::duckdb_rs_extension_api_init(info, access, MINIMUM_DUCKDB_VERSION).unwrap();

        if !have_api_struct {
            return Ok(false);
        }

        // Get the raw database handle BEFORE wrapping in Connection.
        let db_handle: ffi::duckdb_database = *(*access).get_database.unwrap()(info);

        // Create a Connection from the database handle (same as the macro does).
        let connection = Connection::open_from_raw(db_handle.cast())?;

        // Call our init with both the Connection and the raw db handle.
        init_extension(&connection, db_handle)?;

        Ok(true)
    }

    /// FFI entrypoint called by DuckDB when the extension is loaded.
    ///
    /// # Safety
    ///
    /// This is an extern "C" function called across the FFI boundary by DuckDB.
    /// `info` and `access` are guaranteed valid by DuckDB for the call duration.
    #[no_mangle]
    pub unsafe extern "C" fn semantic_views_init_c_api(
        info: ffi::duckdb_extension_info,
        access: *const ffi::duckdb_extension_access,
    ) -> bool {
        let init_result = semantic_views_init_c_api_internal(info, access);

        if let Err(x) = init_result {
            let error_c_string = std::ffi::CString::new(x.to_string());
            match error_c_string {
                Ok(e) => {
                    (*access).set_error.unwrap()(info, e.as_ptr());
                }
                Err(_e) => {
                    let error_alloc_failure = c"An error occurred but the extension failed to allocate memory for an error string";
                    (*access).set_error.unwrap()(info, error_alloc_failure.as_ptr());
                }
            }
            return false;
        }

        init_result.unwrap()
    }
}
