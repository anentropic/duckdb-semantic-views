---
phase: 02-storage-and-ddl
plan: 02-04
task: 2
total_tasks: 2
status: in_progress
last_updated: 2026-02-24T13:30:00.000Z
---

<current_state>
Two bugs identified and one fixed, one still causing issues.

**BUG 1 — FIXED (root cause):** `PRAGMA database_list` filter used `name == "main"` but Python's DuckDB names databases by filename stem (e.g., "restart_test" for "restart_test.db"). So `db_path` was always falling through to `:memory:`, `writer = None`, and defines were never persisted. Fixed in `src/lib.rs` by changing filter to match any non-empty file path.

**BUG 2 — STILL FAILING:** The `try_clone()` approach for the background writer thread is causing a hang/deadlock in the SQLLogicTest. The restart test hangs indefinitely after `define_semantic_view` is called on the file-backed DB, likely because `try_clone()`'d connection deadlocks during invoke.

However: the Python diagnostic test (`/tmp/test_restart3.py`) showed the INSERT reaching the `_definitions` table correctly with `try_clone`. So `try_clone` MAY work — the SQLLogicTest hang could be something else (perhaps the test runner environment, not the extension itself).

Current uncommitted changes: `src/catalog.rs` (SendableConnection wrapper, spawn_catalog_writer takes Connection), `src/lib.rs` (PRAGMA filter fixed, try_clone used instead of Connection::open(path)).
</current_state>

<completed_work>
- Task 1: Resolve host DB path via PRAGMA database_list — DONE and committed (commit 1e24914)
- Task 2 (partial):
  - Background writer thread coded and compiles (commit f1765ba)
  - **ROOT CAUSE FOUND:** PRAGMA filter `name == "main"` was wrong — Python names DBs by filename stem
  - PRAGMA filter fixed in src/lib.rs (uncommitted)
  - Switched to `try_clone()` + `SendableConnection` in catalog.rs (uncommitted)
  - Python diagnostic confirms INSERT reaches `_definitions` table with the fix
  - BUT: SQLLogicTest hangs during restart section (possible deadlock with try_clone)
</completed_work>

<remaining_work>
1. Determine if SQLLogicTest hang is a deadlock with try_clone, or something else
2. If try_clone deadlocks: fallback to Connection::open(path) + FORCE CHECKPOINT approach
3. If try_clone works: confirm SQLLogicTest passes end-to-end
4. Commit the fix
5. Create SUMMARY.md for plan 02-04
6. Update STATE.md and ROADMAP.md
7. Trigger verifier re-run for phase 02
</remaining_work>

<decisions_made>
- **Root cause of restart failure:** PRAGMA database_list filter `name == "main"` was wrong — Python's DuckDB names the main DB by filename stem, so db_path was always ":memory:", writer was always None, and INSERTs were never sent to the background thread.
- **try_clone approach:** Creates a new connection to the SAME DuckDB database instance (not a separate file-level instance). The previous `Connection::open(path)` created a SEPARATE database with independent checkpoint — Python's close-time checkpoint would overwrite Rust's.
- **SendableConnection:** `Connection` is `!Send` due to raw pointer. Wrapping in `struct SendableConnection(Connection)` with `unsafe impl Send` is safe because the background thread has SOLE OWNERSHIP of the connection — no concurrent access.
- **PRAGMA fix:** Changed `.find(|(name, _)| name == "main")` to `.find(|file| !file.is_empty())` — finds first row with non-empty file path, regardless of DB name.
</decisions_made>

<next_action>
Start by running just the restart section in isolation to determine if the hang is a deadlock:

```bash
# First, run the Python diagnostic to confirm try_clone INSERT works
configure/venv/bin/python3 /tmp/test_restart.py

# Then run the full restart test but with a timeout to see if it hangs
timeout 30 just test 2>&1 | tail -30
```

If the SQLLogicTest hangs at `define_semantic_view` (not at restart), it's a deadlock in try_clone during invoke.
If it passes through define but hangs at restart, it's a different issue.

**If try_clone deadlocks in SQLLogicTest:**
Option A: Revert to `Connection::open(path)` but fix persistence by calling CHECKPOINT from Python BEFORE restart:
- Add `CHECKPOINT` statement to the test between `define_semantic_view` and `restart`
- The CHECKPOINT runs on Python's connection (which doesn't see the Rust INSERT)... won't help.

Option B: Try `FORCE CHECKPOINT` from the background thread (not `CHECKPOINT`):
- `FORCE CHECKPOINT` bypasses some lock checks, may work from background thread
- But with `Connection::open(path)` (separate DB), checkpoint still conflicts with Python's close-time checkpoint

Option C: Use `Connection::open(path)` + add `CHECKPOINT` to the test from Python's side at a point where Python CAN see the Rust data — impossible since they're separate DB instances.

Option D: Use a completely different persistence mechanism. The ONLY reliable option that avoids all concurrency issues while writing to the DuckDB file is to use DuckDB's own catalog persistence — i.e., use `COPY`, `EXPORT`, or a DuckDB MACRO.

**Actually, consider this:** What if we use `Connection::open(path)` from the background thread (no deadlock confirmed) AND fix the checkpoint conflict by having the background thread WAIT until Python closes (i.e., defer checkpoint to after the session ends)?

The WAL replay approach: In DuckDB, when a new connection opens a file, it replays any uncommitted WAL entries. If the background thread's INSERT is committed to the WAL (but not checkpointed to main file), and Python's close-time checkpoint only checkpoints Python's view... the new Python connection might see the WAL and replay it.

Let me test this: revert to `Connection::open(path)`, remove the CHECKPOINT call from the background thread entirely, and see if DuckDB's WAL replay on next open includes the committed-but-not-checkpointed INSERT.

This would be the simplest fix: `Connection::open(path)` + no CHECKPOINT = relying on WAL replay.
</next_action>

<blockers>
- try_clone SQLLogicTest hang: need to determine if it's a deadlock or timing issue
- Alternative: Connection::open(path) without CHECKPOINT may work via WAL replay — NEEDS TESTING
</blockers>

<context>
Key insight: the PRAGMA filter fix is the real root cause fix. Everything else (try_clone vs Connection::open, CHECKPOINT) is secondary. Without the filter fix, persistence was NEVER attempted.

With the filter fix, `Connection::open(path)` would have been tried in the original background thread code. The question is whether it persists through restart without CHECKPOINT.

Two separate DuckDB instances on same file: WAL behavior:
- Instance B (Rust) commits INSERT → goes to WAL file (restart_test.db.wal)
- Instance A (Python) closes → checkpoints Python's state → writes Python's WAL to main file
- Question: does Python's checkpoint include or exclude Instance B's WAL entries?
  - If Python's DuckDB only checkpoints what IT wrote to the WAL, Rust's entries might remain in a separate WAL or be lost
  - If both instances share the same WAL file, Python's checkpoint would include all entries

The WAL file is shared (same filesystem path). Whether two separate DuckDB instances can safely share it is the key question.
</context>
